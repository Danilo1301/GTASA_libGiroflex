#define __AML

#include "mod/amlmod.h"
#include "mod/logger.h"
#include "mod/config.h"

/*
#include <stdlib.h>
#include <sys/stat.h>
#include <fstream>
#include <stdint.h>
#include <dlfcn.h>
*/

#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include <vector>

// CLEO
#include "icleo.h"
ICLEO* cleo = nullptr;

#include "mod/thirdparty/inipp.h"
inipp::Ini<char> ini;

// SAUtils
#include "isautils.h"
ISAUtils* sautils = NULL;

// Size of array
#define sizeofA(__aVar)  ((int)(sizeof(__aVar)/sizeof(__aVar[0])))

MYMODCFG(net.danilo1301.giroflex, Giroflex, 1.0.0.0, Danilo1301)
BEGIN_DEPLIST()
ADD_DEPENDENCY_VER(net.rusjj.aml, 1.0.0.6)
END_DEPLIST()

static std::string to_lower(std::string data) {
    std::for_each(data.begin(), data.end(), [](char& c) {
        c = ::tolower(c);
        });
    return data;
}

class CVector {
public:
    float x = 0;
    float y = 0;
    float z = 0;
};

class CRGBA {
public:
    unsigned char r = 0;
    unsigned char g = 0;
    unsigned char b = 0;
    unsigned char a = 0;
};

void* hGTASA = NULL;
uintptr_t pGTASA = 0;

uintptr_t pRegisterCorona1 = 0;
uintptr_t pRegisterCorona2 = 0;

void RegisterCorona(unsigned int id, void* attachTo, unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha, CVector const& posn, float radius, float farClip, int coronaType, int flaretype, bool enableReflection, bool checkObstacles, int _param_not_used, float angle, bool longDistance, float nearClip, unsigned char fadeState, float fadeSpeed, bool onlyFromBelow, bool reflectionDelay)
{
    void (*func)(unsigned int, void*, unsigned char, unsigned char, unsigned char, unsigned char, CVector const&, float, float, int, int, bool, bool, int, float, bool, float, unsigned char, float, bool, bool) = (void (*)(unsigned int, void*, unsigned char, unsigned char, unsigned char, unsigned char, CVector const&, float, float, int, int, bool, bool, int, float, bool, float, unsigned char, float, bool, bool)) pRegisterCorona2;
    
    func(id, attachTo, red, green, blue, alpha, posn, radius, farClip, coronaType, flaretype, enableReflection, checkObstacles, _param_not_used, angle, longDistance, nearClip, fadeState, fadeSpeed, onlyFromBelow, reflectionDelay);

    //aml->Redirect(pGTASA + 0x599FB4 + 0x1, (uintptr_t)SetUpWaterFog_stub);
    //((void(__cdecl*)(unsigned int, uintptr_t*, unsigned char, unsigned char, unsigned char, unsigned char, CVector const&, float, float, int, int, bool, bool, int, float, bool, float, unsigned char, float, bool, bool))0x6FC580)(id, attachTo, red, green, blue, alpha, posn, radius, farClip, coronaType, flaretype, enableReflection, checkObstacles, _param_not_used, angle, longDistance, nearClip, fadeState, fadeSpeed, onlyFromBelow, reflectionDelay);
}

class ModelConfig {
public:
    int modelId = -1;

    std::map<std::string, std::string> data;

    void Print()
    {
        char szTemp[256];

        sprintf(szTemp, "[ModelConfig ID %d]", modelId);
        logger->Info(szTemp);

        for (auto pair : data)
        {
            sprintf(szTemp, "[%s]: %s", pair.first.c_str(), pair.second.c_str());
            logger->Info(szTemp);
        }
    }
};
class VehicleConfigParser
{
public:
    static ModelConfig m_ModelConfig;
    static std::vector<ModelConfig> m_ModelConfigs;

    static bool GetConfigForModelId(int modelId, ModelConfig* config)
    {
        for (auto c : m_ModelConfigs)
        {
            if (c.modelId == modelId)
            {
                *config = c;
                return true;
            }
        }
        return false;
    }

    static bool DoesModelIdHasConfig(int modelId)
    {
        for (auto c : m_ModelConfigs)
        {
            if (c.modelId == modelId) return true;
        }
        return false;
    }

    static std::string GetModelConfigData(int modelId, std::string key)
    {
        ModelConfig config;

        if (GetConfigForModelId(modelId, &config))
        {
            for (auto pair : config.data)
            {
                if (to_lower(pair.first).find(to_lower(key)) == 0)
                {
                    return pair.second;
                }
            }
        }

        return "";
    }

    static int GetModelConfigDataAsInt(int modelId, std::string key)
    {
        auto result = GetModelConfigData(modelId, key);

        if (result.empty())
        {
            return 0;
        }

        return std::atoi(result.c_str());
    }

    static void PushVehicleConfig()
    {
        if (m_ModelConfig.modelId == -1) return;

        char szTemp[256];
        sprintf(szTemp, "--- Push: %d", m_ModelConfig.modelId);
        logger->Info(szTemp);

        m_ModelConfig.Print();
        m_ModelConfigs.push_back(m_ModelConfig);

        m_ModelConfig.modelId = -1;

        logger->Info("------");
    }

    static std::vector<ModelConfig> Parse(std::string path)
    {
        char szTemp[256];

        sprintf(szTemp, "Parse: %s", path.c_str());
        logger->Info(szTemp);

        m_ModelConfigs.clear();

        std::ifstream cfgStream(path);

        std::string line;
        while (getline(cfgStream, line))
        {
            if (line.find("=") == std::string::npos && line.size() > 2)
            {
                PushVehicleConfig();
            }

            int id = -1;
            if (sscanf(line.c_str(), "[ID:%d]", &id) == 1)
            {
                PushVehicleConfig();
                m_ModelConfig.modelId = id;
            }
            
            sprintf(szTemp, "[LINE] %d | %s", m_ModelConfig.modelId, line.c_str());
            logger->Info(szTemp);

            if (line.find("=") != std::string::npos && m_ModelConfig.modelId != -1)
            {
                std::string key = line.substr(0, line.find("="));
                std::string value = line.substr(line.find("=") + 2);

                m_ModelConfig.data[key] = value;

                //sprintf_s_s(szTemp, "Added key '%s' to model ID %d", key.c_str(), m_ModelConfig.modelId);
                //logger->Info(szTemp);
            }
        }

        if (m_ModelConfig.modelId != -1)
            PushVehicleConfig();

        cfgStream.close();

        return m_ModelConfigs;
    }
};

ModelConfig VehicleConfigParser::m_ModelConfig;
std::vector<ModelConfig> VehicleConfigParser::m_ModelConfigs;

//#define __print_to_log(__str)	cleo->PrintToCleoLog(__str); logger->Info(__str)
//#define __reg_opcode	cleo->RegisterOpcode
//#define __reg_func		cleo->RegisterOpcodeFunction

#define __decl_op(__name, __int)	const char* NAME_##__name = #__name; const uint16_t OP_##__name = __int;
#define __print_to_log(__str)		cleo->PrintToCleoLog(__str); logger->Info(__str)
#define __reg_opcode				cleo->RegisterOpcode
#define __reg_func					cleo->RegisterOpcodeFunction
#define __handler_params 			void *handle, uint32_t *ip, uint16_t opcode, const char *name
#define __op_name_match(x) 			opcode == OP_##x || strcmp(name, NAME_##x) == 0
#define __reg_op_func(x, h) 		__reg_opcode(OP_##x, h); __reg_func(NAME_##x, h);

__decl_op(GIROFLEX_CALL, 0x0EF3); // 0EF3=4,giroflex_call %1d% int %2d% string %3s% store_to_address %4x%
//__decl_op(TEST_READ_INT_FROM_INI_FILE, 0x0EF4); // 0EF4=4,%4d% = test_read_int_from_ini_file %1s% section %2s% key %3s%
__decl_op(TEST_OPCODE_2, 0x0EF5); // 0EF5=2,%1d% = test_opcode2 %2d%
__decl_op(CREATE_CUSTOM_WIDGET, 0x0EF6); // 0EF6=5,create_custom_widget id %1d% x %2f% y %3f% texture %4s% store_to_address %5x%
__decl_op(SET_CUSTOM_WIDGET_POSITION, 0x0EF7); // 0EF7=3,set_custom_widget_position id %1d% x %2f% y %3f%
__decl_op(SET_CUSTOM_WIDGET_ENABLED, 0x0EF8); // 0EF8=2,set_custom_widget_enabled id %1d% enabled %2d%

enum GIROFLEX_OPERATION_TYPE
{
    TEST_RETURN_SELF = 0,
    TEST_MULTIPLY_BY_10,
    GET_MODEL_DATA,
    MODEL_HAS_CONFIG,
    TEST_CORONAS
};

void LoadVehicleConfig()
{
    char path[0xFF];
    snprintf(path, sizeof(path), "%s/%s", aml->GetConfigPath(), "net.danilo1301.giroflex.ini");
    VehicleConfigParser::Parse(path);
}

std::map<int, CWidgetButton*> g_Widgets;

void CREATE_CUSTOM_WIDGET(__handler_params)
{
    logger->Info("CREATE_CUSTOM_WIDGET");

    char textureName[64];

    int id = cleo->ReadParam(handle)->i;
    float x = cleo->ReadParam(handle)->f;
    float y = cleo->ReadParam(handle)->f;
    cleo->ReadStringLong(handle, textureName, sizeof(textureName)); textureName[sizeof(textureName) - 1] = 0;
    unsigned int storeToAddress = cleo->ReadParam(handle)->u;

    if(id == -1) id = sautils->FindFreeWidgetId();

    char szTemp[256];
    sprintf(szTemp, "Create widget id %d, texture %s", id, textureName);
    logger->Info(szTemp);

    if (id < 0)
    {
        logger->Info("Could not create widget");
        return;
    }

    CWidgetButton* widget = sautils->CreateWidget(id, 100.0f, 100.0f, 1.0f, "hud_check");

    g_Widgets[id] = widget;


    (*reinterpret_cast<unsigned volatile*>(storeToAddress)) = (unsigned int)id;
}

void SET_CUSTOM_WIDGET_POSITION(__handler_params)
{
    logger->Info("SET_CUSTOM_WIDGET_POSITION");

    int id = cleo->ReadParam(handle)->i; 
    float x = cleo->ReadParam(handle)->f;
    float y = cleo->ReadParam(handle)->f;

    sautils->SetWidgetPos(id, x, y, 1.0f, 1.0f);

    char szTemp[256];
    sprintf(szTemp, "set widget id %d pos to %.2f %.2f", id, x, y);
    logger->Info(szTemp);
}

void SET_CUSTOM_WIDGET_ENABLED(__handler_params)
{
    logger->Info("SET_CUSTOM_WIDGET_ENABLED");

    int id = cleo->ReadParam(handle)->i;
    bool enabled = cleo->ReadParam(handle)->i == 1;

    sautils->ToggleWidget(g_Widgets[id], enabled);
}

void GIROFLEX_CALL(__handler_params)
{
    logger->Info("GIROFLEX_CALL");

    char paramStr[64];

    GIROFLEX_OPERATION_TYPE type = (GIROFLEX_OPERATION_TYPE)cleo->ReadParam(handle)->i;
    int paramInt = cleo->ReadParam(handle)->i;
    cleo->ReadStringLong(handle, paramStr, sizeof(paramStr)); paramStr[sizeof(paramStr) - 1] = 0;
    unsigned int storeToAddress = cleo->ReadParam(handle)->u;

    char szTemp[256];
    sprintf(szTemp, "type: %d,  paramInt: %d,  paramStr: %s,  storeToAddress: %zu", (int)type, paramInt, paramStr, storeToAddress);
    logger->Info(szTemp);

    if (type == GIROFLEX_OPERATION_TYPE::TEST_RETURN_SELF)
    {
        (*reinterpret_cast<unsigned volatile*>(storeToAddress)) = (unsigned int)paramInt;
    }

    if (type == GIROFLEX_OPERATION_TYPE::TEST_MULTIPLY_BY_10)
    {
        (*reinterpret_cast<unsigned volatile*>(storeToAddress)) = (unsigned int)(paramInt * 10);
    }

    if (type == GIROFLEX_OPERATION_TYPE::GET_MODEL_DATA)
    {
        int result = VehicleConfigParser::GetModelConfigDataAsInt(paramInt, paramStr);

        char szTemp[256];
        sprintf(szTemp, "Result = %d", result);
        logger->Info(szTemp);

        (*reinterpret_cast<unsigned volatile*>(storeToAddress)) = (unsigned int)(result);
    }

    if (type == GIROFLEX_OPERATION_TYPE::MODEL_HAS_CONFIG)
    {
        bool result = VehicleConfigParser::DoesModelIdHasConfig(paramInt);

        (*reinterpret_cast<unsigned volatile*>(storeToAddress)) = (unsigned int)(result ? 1 : 0);
    }

    if (type == GIROFLEX_OPERATION_TYPE::TEST_CORONAS)
    {
        int id = 612352;

        CVector pos = { 0, 0, 0 };
        RegisterCorona(612352, NULL, 0, 255, 0, 255, pos, 2.0f, 300.0f, 6, 1, false, false, 0, 0.0f, false, 0.1f, 0, 2.0f, false, false);

        (*reinterpret_cast<unsigned volatile*>(storeToAddress)) = (unsigned int)(id);   
    }
}

void TEST_READ_INT_FROM_INI_FILE(__handler_params)
{
    logger->Info("TEST_READ_INT_FROM_INI_FILE");

    ICLEO::data_t* a = cleo->GetPointerToScriptVar(handle);

    char szTemp[256];
    sprintf(szTemp, "Pointer %X", reinterpret_cast<unsigned int>(a));
    logger->Info(szTemp);
    //cleo->GetPointerToScriptVar(handle)->i = result;
}


void TEST_OPCODE_2(__handler_params)
{
    logger->Info("TEST_OPCODE_2");
    
    ICLEO::data_t* result = cleo->GetPointerToScriptVar(handle);
    int param1 = cleo->ReadParam(handle)->i;

    char szTemp[256];
    sprintf(szTemp, "result pointer: %p, param1 = %d", result, param1);
    logger->Info(szTemp);

    result->i = param1 * 100;
}

const char* pLocations[] = 
{
    "opt1",
    "opt2",
};

void OnLocationChanged(int oldVal, int newVal)
{
    logger->Info("OnLocationChanged");
}

extern "C" void OnModPreLoad()
{
    logger->SetTag("Giroflex");

    logger->Info("Preloading...");
}

extern "C" void OnModLoad()
{
    logger->Info("Loading...");

    logger->Info("Loading libGTASA...");
    hGTASA = dlopen("libGTASA.so", RTLD_LAZY);
    pGTASA = aml->GetLib("libGTASA.so");

    pRegisterCorona1 = aml->GetSym(hGTASA, "CCoronas::_RegisterCorona");
    pRegisterCorona2 = aml->GetSym(hGTASA, "_ZN8CCoronas14RegisterCoronaEjP7CEntityhhhhRK7CVectorffhhhhhfbfbfbb");
    //CSprite2d4DrawERK5CRectRK5CRGBA

    logger->Info("Loading CLEO..");
    if (!(cleo = (ICLEO*)GetInterface("CLEO")))
    {
        logger->Error("CLEO interface not found!");
        return;
    }

    logger->Info("Registering opcode...");
    __print_to_log("Registering opcode... (cleo log)");

    __reg_op_func(GIROFLEX_CALL, GIROFLEX_CALL);
    //__reg_op_func(TEST_READ_INT_FROM_INI_FILE, TEST_READ_INT_FROM_INI_FILE);
    __reg_op_func(TEST_OPCODE_2, TEST_OPCODE_2);
    __reg_op_func(CREATE_CUSTOM_WIDGET, CREATE_CUSTOM_WIDGET);
    __reg_op_func(SET_CUSTOM_WIDGET_POSITION, SET_CUSTOM_WIDGET_POSITION);
    __reg_op_func(SET_CUSTOM_WIDGET_ENABLED, SET_CUSTOM_WIDGET_ENABLED);

    logger->Info("Loading SAUtils...");
    sautils = (ISAUtils*)GetInterface("SAUtils");
    if(sautils)
    {
        sautils->AddClickableItem(SetType_Game, "TestMod Item", 0, 0, sizeofA(pLocations) - 1, pLocations, OnLocationChanged);

        logger->Info("SAUtils loaded");
    }
    else {
        logger->Info("SAUtils interface not found");
    }

    LoadVehicleConfig();

    logger->Info("Loaded");
}
